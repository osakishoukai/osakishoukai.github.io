---
import Layout from "@/layouts/Layout.astro";
import Container from "@/components/container.astro";
import Breadcrumbs from "@/components/ui/Breadcrumbs.astro";

---

<Layout 
  title="ÁîªÂÉè„Çí„É©„É≥„ÉÄ„É†Êï£Â∏É„Éª„Éë„Çø„Éº„É≥‰ΩúÊàê | „Å°„Çä„Å∞„ÇÅ„Éº„Åã„Éº - „Åä„Åä„Åï„Åç„É©„Éú" 
  description="ÁîªÂÉè„Çí„É©„É≥„ÉÄ„É†„Å´ÈÖçÁΩÆ„Åó„Å¶„ÄÅ„Åä„Åó„ÇÉ„Çå„Å™„Éë„Çø„Éº„É≥ÁîªÂÉè„ÇíÁû¨ÊôÇ„Å´ÁîüÊàê„ÄÇ„Ç∑„Éº„ÉâÂÄ§Âà∂Âæ°„ÇÑ„Çµ„Ç§„Ç∫„ÉªËßíÂ∫¶„ÅÆ„É©„É≥„ÉÄ„É†Ë™øÊï¥„ÄÅ„Ç∑„Éº„É†„É¨„Çπ„Éë„Çø„Éº„É≥‰ΩúÊàêÊ©üËÉΩ‰ªò„Åç„ÄÇ"
>
  <Container>
    <Breadcrumbs items={[
      { label: "„Åä„Åä„Åï„Åç„É©„Éú", href: "/lab" },
      { label: "„Å°„Çä„Å∞„ÇÅ„Éº„Åã„Éº" }
    ]} />

    <div class="tool-header-section">
      <div class="tool-icon-wrapper">
        <div class="tool-icon">üåå</div>
      </div>
      <div class="tool-info">
        <h1 class="tool-title">„Å°„Çä„Å∞„ÇÅ„Éº„Åã„Éº</h1>
        <p class="tool-description">
          ÁîªÂÉè„Çí„É©„É≥„ÉÄ„É†„Å´„Å°„Çä„Å∞„ÇÅ„Å¶Êñ∞„Åó„ÅÑÁîªÂÉè„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ<br/>
          URLCard„Å®„Åã„Åä„Åä„Åï„Åç„Åè„ÇìÊúç„Çí„Åì„Çå„Åß‰Ωú„Å£„Å¶„Çã„ÇàÔºÅ
        </p>
      </div>
    </div>

    <div class="tool-card">
      <div class="tool-content">
        <div class="scatter-layout">
          <div class="scatter-controls">
            <div class="control-group">
              <label>„Ç∑„Éº„ÉâÂÄ§</label>
              <div class="seed-input-group">
                <input type="number" id="sc-seed" value="42" />
                <button id="sc-random-seed" class="btn-small">üé≤</button>
              </div>
            </div>
            <div class="control-group">
              <label>Êï£Â∏ÉÈáè: <span id="val-count">100</span></label>
              <input type="range" id="sc-count" min="1" max="1000" value="100" />
            </div>
            <div class="control-group">
              <label>„Çµ„Ç§„Ç∫: <span id="val-size-range">0.1 - 0.5</span></label>
              <div class="dual-range" id="sc-size-range-container">
                <div class="slider-track"></div>
                <input type="range" id="sc-size-min" min="0.01" max="2" step="0.01" value="0.1" />
                <input type="range" id="sc-size-max" min="0.01" max="2" step="0.01" value="0.5" />
              </div>
            </div>
            <div class="control-group">
              <label>ËßíÂ∫¶: <span id="val-angle-range">0¬∞ - 360¬∞</span></label>
              <div class="dual-range" id="sc-angle-range-container">
                <div class="slider-track"></div>
                <input type="range" id="sc-angle-min" min="0" max="360" value="0" />
                <input type="range" id="sc-angle-max" min="0" max="360" value="360" />
              </div>
            </div>
            <div class="control-group checkbox-group">
              <input type="checkbox" id="sc-overlap" />
              <label for="sc-overlap">‰∏çÈÄèÊòéÈÉ®ÂàÜ„ÅÆÈáçË§á„ÇíË®±ÂèØ (Âä†ÁÆóÂêàÊàê)</label>
            </div>
            <div class="control-group">
              <label>„Ç∑„Éº„É†„É¨„ÇπÂåñ</label>
              <div class="control-row">
                <div class="control-group checkbox-group">
                  <input type="checkbox" id="sc-seamless-x" checked />
                  <label for="sc-seamless-x">Ê®™</label>
                </div>
                <div class="control-group checkbox-group">
                  <input type="checkbox" id="sc-seamless-y" checked />
                  <label for="sc-seamless-y">Á∏¶</label>
                </div>
              </div>
            </div>
            <div class="control-group">
              <label>ËÉåÊôØËâ≤</label>
              <div class="color-control-group">
                <input type="color" id="sc-bg-color" value="#000000" />
              </div>
            </div>
            <div class="control-group">
              <label>Âá∫ÂäõËß£ÂÉèÂ∫¶</label>
              <select id="sc-resolution">
                <option value="512">512x512</option>
                <option value="1024">1024x1024</option>
                <option value="2048" selected>2048x2048 (È´òÁîªË≥™)</option>
              </select>
            </div>
            <div class="actions">
              <button id="sc-download" class="btn btn-primary"><span>üíæ</span> ‰øùÂ≠ò</button>
            </div>
          </div>

          <div class="scatter-preview">
            <div class="drop-zone" id="sc-drop-zone">
              <input type="file" id="sc-file-input" accept="image/*" class="file-input" />
              <div class="drop-zone-text">
                <span class="upload-icon">‚ú®</span>
                <p>ÂÖÉÁîªÂÉè„Çí„Éâ„É≠„ÉÉ„Éó</p>
              </div>
            </div>
            <div id="sc-preview-container" class="preview-container hidden">
              <canvas id="sc-canvas"></canvas>
              <div class="canvas-info">„É™„Ç¢„É´„Çø„Ç§„É†„Éó„É¨„Éì„É•„Éº</div>
              <button id="sc-reset" class="btn-small mt-2">„É™„Çª„ÉÉ„Éà</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="legal-note">
      <a href="/about/legal#lab-terms">Âà©Áî®Ë¶èÁ¥ÑÔºàÊ®©Âà©„Å®ÂÖçË≤¨Ôºâ„ÇíÁ¢∫Ë™ç„Åô„Çã &rarr;</a>
    </div>
  </Container>
</Layout>

<script>
  // --- Common Utilities ---
  function mulberry32(a: number) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // --- Tool 1: „Å°„Çä„Å∞„ÇÅ„Éº„Åã„Éº ---
  const scDropZone = document.getElementById('sc-drop-zone');
  const scFileInput = document.getElementById('sc-file-input') as HTMLInputElement;
  const scCanvas = document.getElementById('sc-canvas') as HTMLCanvasElement;
  const scPreviewContainer = document.getElementById('sc-preview-container');
  const scDownloadBtn = document.getElementById('sc-download');
  const scResetBtn = document.getElementById('sc-reset');
  const scRandomSeedBtn = document.getElementById('sc-random-seed');

  // Controls
  const scControls = {
    seed: document.getElementById('sc-seed') as HTMLInputElement,
    count: document.getElementById('sc-count') as HTMLInputElement,
    sizeMin: document.getElementById('sc-size-min') as HTMLInputElement,
    sizeMax: document.getElementById('sc-size-max') as HTMLInputElement,
    angleMin: document.getElementById('sc-angle-min') as HTMLInputElement,
    angleMax: document.getElementById('sc-angle-max') as HTMLInputElement,
    overlap: document.getElementById('sc-overlap') as HTMLInputElement,
    resolution: document.getElementById('sc-resolution') as HTMLSelectElement,
    seamlessX: document.getElementById('sc-seamless-x') as HTMLInputElement,
    seamlessY: document.getElementById('sc-seamless-y') as HTMLInputElement,
    bgColor: document.getElementById('sc-bg-color') as HTMLInputElement,
  };

  const scValues = {
    count: document.getElementById('val-count'),
    sizeRange: document.getElementById('val-size-range'),
    angleRange: document.getElementById('val-angle-range'),
  };

  let sourceImage: HTMLImageElement | null = null;

  // --- Overlap Detection Helpers ---
  const checkCanvas = document.createElement('canvas');
  const cctx = checkCanvas.getContext('2d', { willReadFrequently: true });

  function checkOverlap(x: number, y: number, scale: number, angle: number, hitCanvas: HTMLCanvasElement, hitScale: number) {
    if (!cctx || !sourceImage) return false;
    const w = sourceImage.width * scale * hitScale;
    const h = sourceImage.height * scale * hitScale;
    const diag = Math.sqrt(w * w + h * h) || 1;
    
    checkCanvas.width = Math.ceil(diag);
    checkCanvas.height = Math.ceil(diag);
    
    cctx.clearRect(0, 0, checkCanvas.width, checkCanvas.height);
    cctx.save();
    cctx.translate(checkCanvas.width / 2, checkCanvas.height / 2);
    cctx.rotate(angle);
    cctx.drawImage(sourceImage, -w / 2, -h / 2, w, h);
    cctx.restore();
    
    cctx.globalCompositeOperation = 'source-in';
    cctx.drawImage(hitCanvas, -x * hitScale + checkCanvas.width / 2, -y * hitScale + checkCanvas.height / 2);
    
    const imgData = cctx.getImageData(0, 0, checkCanvas.width, checkCanvas.height).data;
    for (let i = 3; i < imgData.length; i += 4) {
      if (imgData[i] > 10) return true; // Overlap detected
    }
    return false;
  }


  scDropZone?.addEventListener('click', () => scFileInput?.click());
  scDropZone?.addEventListener('dragover', (e) => { e.preventDefault(); scDropZone.classList.add('drag-over'); });
  ['dragleave', 'dragend'].forEach(t => scDropZone?.addEventListener(t, () => scDropZone.classList.remove('drag-over')));
  scDropZone?.addEventListener('drop', (e) => {
    e.preventDefault();
    scDropZone.classList.remove('drag-over');
    if (e.dataTransfer?.files.length) handleScFile(e.dataTransfer.files[0]);
  });
  scFileInput?.addEventListener('change', () => {
    if (scFileInput.files?.length) handleScFile(scFileInput.files[0]);
  });

  function handleScFile(file: File) {
    if (!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        sourceImage = img;
        scDropZone?.classList.add('hidden');
        scPreviewContainer?.classList.remove('hidden');
        updateScatter();
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }

  // Event listeners for sliders and inputs
  Object.entries(scControls).forEach(([key, ctrl]) => {
    const eventType = ctrl instanceof HTMLSelectElement || ctrl.type === 'checkbox' || ctrl.type === 'color' ? 'change' : 'input';
    
    ctrl.addEventListener(eventType, () => {
      // Constraints for dual sliders
      if (key === 'sizeMin') {
        if (parseFloat(scControls.sizeMin.value) > parseFloat(scControls.sizeMax.value)) {
          scControls.sizeMin.value = scControls.sizeMax.value;
        }
      }
      if (key === 'sizeMax') {
        if (parseFloat(scControls.sizeMax.value) < parseFloat(scControls.sizeMin.value)) {
          scControls.sizeMax.value = scControls.sizeMin.value;
        }
      }
      if (key === 'angleMin') {
        if (parseInt(scControls.angleMin.value) > parseInt(scControls.angleMax.value)) {
          scControls.angleMin.value = scControls.angleMax.value;
        }
      }
      if (key === 'angleMax') {
        if (parseInt(scControls.angleMax.value) < parseInt(scControls.angleMin.value)) {
          scControls.angleMax.value = scControls.angleMin.value;
        }
      }

      updateLabels();
      updateScatter();
    });
  });

  scRandomSeedBtn?.addEventListener('click', () => {
    scControls.seed.value = Math.floor(Math.random() * 10000).toString();
    updateScatter();
  });

  scResetBtn?.addEventListener('click', () => {
    sourceImage = null;
    scPreviewContainer?.classList.add('hidden');
    scDropZone?.classList.remove('hidden');
    if (scFileInput) scFileInput.value = '';
  });

  function updateLabels() {
    if (scValues.count) scValues.count.textContent = scControls.count.value;
    
    if (scValues.sizeRange) {
      scValues.sizeRange.textContent = `${scControls.sizeMin.value} - ${scControls.sizeMax.value}`;
    }
    if (scValues.angleRange) {
      scValues.angleRange.textContent = `${scControls.angleMin.value}¬∞ - ${scControls.angleMax.value}¬∞`;
    }

    updateSliderTrack('sc-size-range-container', scControls.sizeMin, scControls.sizeMax);
    updateSliderTrack('sc-angle-range-container', scControls.angleMin, scControls.angleMax);
  }

  function updateSliderTrack(containerId: string, minInput: HTMLInputElement, maxInput: HTMLInputElement) {
    const container = document.getElementById(containerId);
    const track = container?.querySelector('.slider-track') as HTMLElement;
    if (!track) return;

    const min = parseFloat(minInput.min);
    const max = parseFloat(minInput.max);
    const valMin = parseFloat(minInput.value);
    const valMax = parseFloat(maxInput.value);

    const percent1 = ((valMin - min) / (max - min)) * 100;
    const percent2 = ((valMax - min) / (max - min)) * 100;

    track.style.background = `linear-gradient(to right, #eee ${percent1}%, var(--main-color) ${percent1}%, var(--main-color) ${percent2}%, #eee ${percent2}%)`;
  }

  // Initial call
  updateLabels();

  let updateTimeout: any;
  function updateScatter() {
    if (!sourceImage) return;
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => {
      renderScatter();
    }, 10);
  }

  function renderScatter() {
    if (!sourceImage || !scCanvas) return;
    const res = parseInt(scControls.resolution.value);
    scCanvas.width = res;
    scCanvas.height = res;
    const ctx = scCanvas.getContext('2d');
    if (!ctx) return;

    const seed = parseInt(scControls.seed.value) || 0;
    const rand = mulberry32(seed);
    const count = parseInt(scControls.count.value);
    const sMin = parseFloat(scControls.sizeMin.value);
    const sMax = parseFloat(scControls.sizeMax.value);
    const aMin = parseFloat(scControls.angleMin.value) * Math.PI / 180;
    const aMax = parseFloat(scControls.angleMax.value) * Math.PI / 180;
    const allowOverlap = scControls.overlap.checked;
    const seamlessX = scControls.seamlessX.checked;
    const seamlessY = scControls.seamlessY.checked;
    const bgColor = scControls.bgColor.value;

    if (allowOverlap) {
      // Allow overlapping (Addition composition)
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, res, res);
      
      ctx.globalCompositeOperation = 'lighter';

      for (let i = 0; i < count; i++) {
        const x = rand() * res;
        const y = rand() * res;
        const scale = sMin + rand() * (sMax - sMin);
        const angle = aMin + rand() * (aMax - aMin);

        const drawAt = (dx: number, dy: number) => {
          ctx.save();
          ctx.translate(dx, dy);
          ctx.rotate(angle);
          const w = sourceImage.width * scale;
          const h = sourceImage.height * scale;
          ctx.drawImage(sourceImage, -w / 2, -h / 2, w, h);
          ctx.restore();
        };

        drawAt(x, y);
        
        // Seamless tiling
        if (seamlessX) {
          drawAt(x - res, y);
          drawAt(x + res, y);
        }
        if (seamlessY) {
          drawAt(x, y - res);
          drawAt(x, y + res);
        }
        if (seamlessX && seamlessY) {
          drawAt(x - res, y - res);
          drawAt(x + res, y - res);
          drawAt(x - res, y + res);
          drawAt(x + res, y + res);
        }
      }
    } else {
      // Disallow overlapping
      ctx.clearRect(0, 0, res, res);
      ctx.globalCompositeOperation = 'source-over';

      const hitScale = 0.25; // Use smaller scale for hit testing performance
      const hitCanvas = document.createElement('canvas');
      hitCanvas.width = res * hitScale;
      hitCanvas.height = res * hitScale;
      const hctx = hitCanvas.getContext('2d', { willReadFrequently: true });
      if (!hctx) return;

      for (let i = 0; i < count; i++) {
        let placed = false;
        // Try up to 10 random positions/scales for each count
        for (let tries = 0; tries < 10; tries++) {
          const x = rand() * res;
          const y = rand() * res;
          const scale = sMin + rand() * (sMax - sMin);
          const angle = aMin + rand() * (aMax - aMin);

          if (!checkOverlap(x, y, scale, angle, hitCanvas, hitScale)) {
            const drawMainAt = (dx: number, dy: number) => {
              ctx.save();
              ctx.translate(dx, dy);
              ctx.rotate(angle);
              const w = sourceImage.width * scale;
              const h = sourceImage.height * scale;
              ctx.drawImage(sourceImage, -w / 2, -h / 2, w, h);
              ctx.restore();
            };

            const drawHitAt = (dx: number, dy: number) => {
              hctx.save();
              hctx.translate(dx * hitScale, dy * hitScale);
              hctx.rotate(angle);
              hctx.drawImage(sourceImage, (-sourceImage.width * scale * hitScale) / 2, (-sourceImage.height * scale * hitScale) / 2, sourceImage.width * scale * hitScale, sourceImage.height * scale * hitScale);
              hctx.restore();
            };

            // Draw to main canvas
            drawMainAt(x, y);
            if (seamlessX) {
              drawMainAt(x - res, y);
              drawMainAt(x + res, y);
            }
            if (seamlessY) {
              drawMainAt(x, y - res);
              drawMainAt(x, y + res);
            }
            if (seamlessX && seamlessY) {
              drawMainAt(x - res, y - res);
              drawMainAt(x + res, y - res);
              drawMainAt(x - res, y + res);
              drawMainAt(x + res, y + res);
            }

            // Draw to hit canvas
            drawHitAt(x, y);
            if (seamlessX) {
              drawHitAt(x - res, y);
              drawHitAt(x + res, y);
            }
            if (seamlessY) {
              drawHitAt(x, y - res);
              drawHitAt(x, y + res);
            }
            if (seamlessX && seamlessY) {
              drawHitAt(x - res, y - res);
              drawHitAt(x + res, y - res);
              drawHitAt(x - res, y + res);
              drawHitAt(x + res, y + res);
            }

            placed = true;
            break;
          }
        }
      }

      // Fill background after scattering
      ctx.globalCompositeOperation = 'destination-over';
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, res, res);
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  scDownloadBtn?.addEventListener('click', () => {
    if (!scCanvas) return;
    scCanvas.toBlob((blob) => {
      if (!blob) return;
      const link = document.createElement('a');
      link.download = `scatter_${scControls.seed.value}.png`;
      link.href = URL.createObjectURL(blob);
      link.click();
      setTimeout(() => URL.revokeObjectURL(link.href), 100);
    }, 'image/png');
  });
</script>

<style>
  /* Common Tool Styles */
  .tool-header-section {
    display: flex;
    align-items: center;
    gap: 2rem;
    margin-bottom: 3rem;
  }

  .tool-icon-wrapper {
    background: white;
    width: 6rem;
    height: 6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.1);
  }

  .tool-icon {
    font-size: 3rem;
  }

  .tool-title {
    font-size: 2rem;
    font-weight: 900;
    color: var(--main-color);
    margin-bottom: 0.5rem;
  }

  .tool-description {
    font-size: 1.1rem;
    color: var(--sub-color);
    opacity: 0.8;
    line-height: 1.6;
  }

  .tool-card {
    background: white;
    border: 2px solid var(--main-color);
    border-radius: 2rem;
    padding: 3rem;
    margin-bottom: 3rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.05);
  }

  .legal-note {
    text-align: center;
    margin-top: 2rem;
  }
  
  .legal-note a {
    color: var(--sub-color);
    text-decoration: underline;
    font-size: 0.9rem;
    opacity: 0.7;
    transition: opacity 0.3s;
  }
  
  .legal-note a:hover {
    opacity: 1;
  }

  .drop-zone {
    border: 3px dashed var(--main-color);
    border-radius: 2rem;
    padding: 4rem 2rem;
    text-align: center;
    cursor: pointer;
    background: rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease;
  }

  .drop-zone:hover, .drop-zone.drag-over {
    background: var(--bg-color);
    border-color: var(--accent-color);
    transform: scale(1.02);
  }
  
  .upload-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: 1rem;
  }

  .file-input { display: none; }
  
  .hidden { display: none !important; }

  /* Controls Common */
  input[type="number"], select {
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #ddd;
    font-size: 1rem;
  }

  .btn {
    padding: 0.75rem 1.5rem;
    border-radius: 1rem;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1rem;
  }
  
  .btn-small {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-size: 0.8rem;
      font-weight: 800;
      cursor: pointer;
      border: 1px solid #ddd;
      background: white;
  }
  .btn-small:hover { background: #f0f0f0; }

  .btn-primary { background: var(--main-color); color: white; }
  .btn-primary:hover { transform: translateY(-3px); box-shadow: 0 10px 20px rgba(207,61,49,0.3); }

  /* Scatter Specific */
  .scatter-layout {
    display: grid;
    grid-template-columns: 350px 1fr;
    gap: 3rem;
  }

  .scatter-controls {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    background: rgba(0,0,0,0.02);
    padding: 2rem;
    border-radius: 1.5rem;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .control-group label {
    font-weight: 800;
    font-size: 0.9rem;
    color: var(--sub-color);
  }
  
  .control-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
  }

  .checkbox-group {
      flex-direction: row;
      align-items: center;
      gap: 0.75rem;
  }

  .checkbox-group input { width: auto; }

  .seed-input-group {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .seed-input-group input[type="number"] {
    flex: 1;
  }

  .color-control-group {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    background: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid #ddd;
  }

  .color-control-group input[type="color"] {
    border: none;
    width: 40px;
    height: 30px;
    padding: 0;
    cursor: pointer;
    background: none;
  }

  /* Dual Range States */
  .dual-range {
    position: relative;
    height: 30px;
    display: flex;
    align-items: center;
  }

  .dual-range input[type="range"] {
    position: absolute;
    width: 100%;
    pointer-events: none;
    appearance: none;
    background: none;
    z-index: 2;
    margin: 0;
  }

  /* Thumbs and Tracks */
  .dual-range input[type="range"]::-webkit-slider-thumb {
    pointer-events: auto;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--main-color);
    border-radius: 50%;
    cursor: pointer;
    border: 3px solid white;
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    transition: transform 0.1s ease;
  }

  .dual-range input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.1);
  }

  .slider-track {
    position: absolute;
    width: 100%;
    height: 6px;
    background: #eee;
    border-radius: 3px;
    z-index: 1;
  }

  input[type="range"] { width: 100%; cursor: pointer; }

  .scatter-preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  .preview-container {
    width: 100%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #sc-canvas {
    max-width: 100%;
    max-height: 60vh;
    border-radius: 1rem;
    box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    background: #000;
  }
  
  .canvas-info {
    margin-top: 1rem;
    font-size: 0.8rem;
    font-weight: 700;
    opacity: 0.5;
  }
  
  .mt-2 { margin-top: 0.5rem; }

  @media (max-width: 900px) {
    .scatter-layout {
      grid-template-columns: 1fr;
    }
  }
</style>
