---
import Layout from "@/layouts/Layout.astro";
import Container from "@/components/container.astro";
import Breadcrumbs from "@/components/ui/Breadcrumbs.astro";

---

<Layout 
  title="ç”»åƒã‚’ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ãƒ»SVGå¤‰æ› | ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼ - ãŠãŠã•ããƒ©ãƒœ" 
  description="ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸå†™çœŸã‚’ã‚¤ãƒ©ã‚¹ãƒˆé¢¨ã®ãƒ™ã‚¯ã‚¿ãƒ¼ç”»åƒï¼ˆSVGï¼‰ã«ç¬æ™‚ã«å¤‰æ›ã€‚è‰²æ•°ã‚„ãªã‚ã‚‰ã‹ã•ã‚’èª¿æ•´ã—ã¦ã€ãƒ­ã‚´åˆ¶ä½œã‚„ãƒ•ãƒ©ãƒƒãƒˆãƒ‡ã‚¶ã‚¤ãƒ³ã®ç´ æä½œã‚Šã«æ´»ç”¨ã§ãã¾ã™ã€‚"
>
  <Container>
    <Breadcrumbs items={[
      { label: "ãŠãŠã•ããƒ©ãƒœ", href: "/lab" },
      { label: "ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼" }
    ]} />

    <div class="tool-header-section">
      <div class="tool-icon-wrapper">
        <div class="tool-icon">ğŸ–‹ï¸</div>
      </div>
      <div class="tool-info">
        <h1 class="tool-title">ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼</h1>
        <p class="tool-description">
          å†™çœŸã‚’ã‚¤ãƒ©ã‚¹ãƒˆé¢¨ã®ãƒ™ã‚¯ã‚¿ãƒ¼ç”»åƒï¼ˆSVGï¼‰ã«å¤‰æ›ã—ã¾ã™ã€‚<br/>
          è‰²æ•°ã‚’èª¿æ•´ã—ã¦ã€ãƒ­ã‚´åˆ¶ä½œã‚„ãƒ•ãƒ©ãƒƒãƒˆãƒ‡ã‚¶ã‚¤ãƒ³ã®ç´ æä½œã‚Šã«ï¼
        </p>
      </div>
    </div>

    <div class="tool-card">
      <div class="tool-content">
        <div class="tracer-layout">
          <div class="tracer-controls">
            <div class="control-group">
              <label>è‰²æ•°</label>
              <input type="number" id="tr-colors" min="2" max="64" value="8" style="width: 80px;" />
            </div>
            <div class="control-group">
              <label>ãªã‚ã‚‰ã‹ã•</label>
              <select id="tr-detail">
                <option value="1">ä½ï¼ˆã‚«ã‚¯ã‚«ã‚¯ï¼‰</option>
                <option value="2" selected>ä¸­ï¼ˆæ¨™æº–ï¼‰</option>
                <option value="3">é«˜ï¼ˆãªã‚ã‚‰ã‹ï¼‰</option>
              </select>
            </div>
            <div class="actions">
              <button id="tr-download" class="btn btn-primary">
                <span>ğŸ’¾</span> ä¿å­˜
              </button>
              <button id="tr-reset" class="btn btn-secondary">ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
          </div>

          <div class="tracer-preview">
            <div class="drop-zone" id="tr-drop-zone">
              <input type="file" id="tr-file-input" accept="image/*" class="file-input" />
              <div class="drop-zone-text">
                <span class="upload-icon">ğŸ–‹ï¸</span>
                <p>ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–</p>
              </div>
            </div>
            <div id="tr-preview-container" class="preview-container hidden">
              <div id="tr-svg-container" class="svg-preview"></div>
              <div class="canvas-info">SVGãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</div>
            </div>
          </div>
        </div>
      </div>
  </Container>
</Layout>

<script is:inline src="https://unpkg.com/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>

<script>
  // --- Tool 3: ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼ ---
  const trDropZone = document.getElementById('tr-drop-zone');
  const trFileInput = document.getElementById('tr-file-input') as HTMLInputElement;
  const trPreviewContainer = document.getElementById('tr-preview-container');
  const trSvgContainer = document.getElementById('tr-svg-container');
  const trDownloadBtn = document.getElementById('tr-download');
  const trResetBtn = document.getElementById('tr-reset');

  const trControls = {
    colors: document.getElementById('tr-colors') as HTMLInputElement,
    detail: document.getElementById('tr-detail') as HTMLSelectElement,
  };

  let trSourceImage: string | null = null;
  let currentSvgStr: string | null = null;
  let sourceImageElement: HTMLImageElement | null = null;
  let currentPalette: {r:number, g:number, b:number, a:number}[] = [];

  function handleTrFile(file: File) {
    if (!file.type.startsWith('image/')) { return; }
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        sourceImageElement = img;
        trSourceImage = e.target?.result as string;
        trDropZone?.classList.add('hidden');
        trPreviewContainer?.classList.remove('hidden');
        updateAll();
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }

  function updateAll(forcePalette = false) {
    if (forcePalette || currentPalette.length === 0) {
      const palette = extractPaletteFromImage();
      if (palette) {
        currentPalette = palette;
      }
    }
    
    if (currentPalette.length > 0) {
      renderVector(currentPalette);
    }
  }

  function extractPaletteFromImage() {
    if (!sourceImageElement || !trControls.colors) return null;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    
    // Resize for analysis
    const maxSize = 100;
    const scale = Math.min(maxSize / sourceImageElement.width, maxSize / sourceImageElement.height);
    canvas.width = Math.max(1, sourceImageElement.width * scale);
    canvas.height = Math.max(1, sourceImageElement.height * scale);
    
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(sourceImageElement, 0, 0, canvas.width, canvas.height);
    const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    const numColors = parseInt(trControls.colors.value);
    
    // 1. Quantize and count frequencies
    const colorMap = new Map<string, number>();
    for (let i = 0; i < pixels.length; i += 4) {
      if (pixels[i+3] < 128) continue;
      // Quantize and clamp correctly
      const r = Math.min(255, Math.max(0, Math.round(pixels[i] / 16) * 16));
      const g = Math.min(255, Math.max(0, Math.round(pixels[i+1] / 16) * 16));
      const b = Math.min(255, Math.max(0, Math.round(pixels[i+2] / 16) * 16));
      const key = `${r},${g},${b}`;
      colorMap.set(key, (colorMap.get(key) || 0) + 1);
    }

    // 2. Sort by frequency (descending)
    const sortedColors = Array.from(colorMap.entries())
      .map(([key, count]) => ({
        rgb: key.split(',').map(Number),
        count
      }))
      .sort((a, b) => b.count - a.count);

    // 3. Select diverse colors from most frequent ones
    const picked: number[][] = [];
    const minDiff = 32; // Threshold for color similarity

    for (const color of sortedColors) {
      if (picked.length >= numColors) break;
      
      const isDiverse = picked.every(p => {
        // Simple Manhattan distance for speed
        const dist = Math.abs(color.rgb[0] - p[0]) + 
                     Math.abs(color.rgb[1] - p[1]) + 
                     Math.abs(color.rgb[2] - p[2]);
        return dist > minDiff;
      });

      if (isDiverse) {
        picked.push(color.rgb);
      }
    }

    // 4. Fill remaining slots with the next most distant color if needed
    if (picked.length < numColors && sortedColors.length > picked.length) {
       for (const color of sortedColors) {
         if (picked.length >= numColors) break;
         if (!picked.some(p => p[0] === color.rgb[0] && p[1] === color.rgb[1] && p[2] === color.rgb[2])) {
           picked.push(color.rgb);
         }
       }
    }

    return picked.map(c => ({r: c[0], g: c[1], b: c[2], a: 255}));
  }

  function renderVector(palette: {r:number, g:number, b:number, a:number}[]) {
    if (!trSourceImage || !trSvgContainer || !trControls.detail) return;
    const detail = parseInt(trControls.detail.value);

    // @ts-ignore
    ImageTracer.imageToSVG(
      trSourceImage,
      (svgstr: string) => {
        if (palette.length > 0) {
           const bg = palette[0];
           const bgRect = `<rect width="100%" height="100%" fill="rgb(${bg.r},${bg.g},${bg.b})" />`;
           svgstr = svgstr.replace(/<svg(.*?)>/, `<svg$1>${bgRect}`);
        }
        
        currentSvgStr = svgstr;
        if (trSvgContainer) trSvgContainer.innerHTML = svgstr;
      },
      { 
        pal: palette,
        ltres: detail === 3 ? 0.05 : detail === 2 ? 2 : 20,
        qtres: detail === 3 ? 0.05 : detail === 2 ? 2 : 20,
        pathomit: detail === 3 ? 8 : detail === 2 ? 64 : 512,
        // ãƒ‘ã‚¹åŒå£«ã‚’ã‚ãšã‹ã«é‡ã­ã¦ç™½èƒŒæ™¯ãŒæ¼ã‚Œã‚‹ã®ã‚’é˜²ã
        strokewidth: 1, 
        viewbox: true,
        blurradius: detail === 1 ? 3 : 0,
        blurdelta: 20
      }
    );
  }

  Object.entries(trControls).forEach(([key, ctrl]) => {
    if (!ctrl) return;
    const eventType = ctrl instanceof HTMLSelectElement || ctrl.type === 'number' ? 'change' : 'input';
    ctrl.addEventListener(eventType, () => {
      if (key === 'colors') {
        updateAll(true); // è‰²æ•°ãŒå¤‰ã‚ã£ãŸã‚‰ãƒ‘ãƒ¬ãƒƒãƒˆã‚’å†æŠ½å‡º
      } else {
        updateAll(false); // ãªã‚ã‚‰ã‹ã•ãªã©ã®å¤‰æ›´ã¯ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç¶­æŒ
      }
    });
  });

  trDropZone?.addEventListener('click', () => trFileInput?.click());
  trDropZone?.addEventListener('dragover', (e) => { e.preventDefault(); trDropZone.classList.add('drag-over'); });
  ['dragleave', 'dragend'].forEach(t => trDropZone?.addEventListener(t, () => trDropZone.classList.remove('drag-over')));
  trDropZone?.addEventListener('drop', (e) => {
    e.preventDefault();
    trDropZone.classList.remove('drag-over');
    if (e.dataTransfer?.files.length) handleTrFile(e.dataTransfer.files[0]);
  });
  trFileInput?.addEventListener('change', () => {
    if (trFileInput.files?.length) handleTrFile(trFileInput.files[0]);
  });

  trDownloadBtn?.addEventListener('click', () => {
    if (!currentSvgStr) return;
    const blob = new Blob([currentSvgStr], { type: 'image/svg+xml' });
    const link = document.createElement('a');
    link.download = 'vectorized.svg';
    link.href = URL.createObjectURL(blob);
    link.click();
  });

  trResetBtn?.addEventListener('click', () => {
    trSourceImage = null;
    currentSvgStr = null;
    trPreviewContainer?.classList.add('hidden');
    trDropZone?.classList.remove('hidden');
    if (trFileInput) trFileInput.value = '';
    if (trSvgContainer) trSvgContainer.innerHTML = '';
  });
</script>

<style>
  /* Common Tool Styles */
  .tool-header-section {
    display: flex;
    align-items: center;
    gap: 2rem;
    margin-bottom: 3rem;
  }

  .tool-icon-wrapper {
    background: white;
    width: 6rem;
    height: 6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.1);
  }

  .tool-icon {
    font-size: 3rem;
  }

  .tool-title {
    font-size: 2rem;
    font-weight: 900;
    color: var(--main-color);
    margin-bottom: 0.5rem;
  }

  .tool-description {
    font-size: 1.1rem;
    color: var(--sub-color);
    opacity: 0.8;
    line-height: 1.6;
  }

  .tool-card {
    background: white;
    border: 2px solid var(--main-color);
    border-radius: 2rem;
    padding: 3rem;
    margin-bottom: 3rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.05);
  }

  .legal-note {
    text-align: center;
    margin-top: 2rem;
  }
  
  .legal-note a {
    color: var(--sub-color);
    text-decoration: underline;
    font-size: 0.9rem;
    opacity: 0.7;
    transition: opacity 0.3s;
  }
  
  .legal-note a:hover {
    opacity: 1;
  }

  .drop-zone {
    border: 3px dashed var(--main-color);
    border-radius: 2rem;
    padding: 4rem 2rem;
    text-align: center;
    cursor: pointer;
    background: rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease;
  }

  .drop-zone:hover, .drop-zone.drag-over {
    background: var(--bg-color);
    border-color: var(--accent-color);
    transform: scale(1.02);
  }

  .upload-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: 1rem;
  }

  .file-input { display: none; }
  
  .hidden { display: none !important; }

  /* Controls */
  input[type="number"], select {
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #ddd;
    font-size: 1rem;
  }

  .btn {
    padding: 0.75rem 1.5rem;
    border-radius: 1rem;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1rem;
  }

  .btn-primary { background: var(--main-color); color: white; }
  .btn-primary:hover { transform: translateY(-3px); box-shadow: 0 10px 20px rgba(207,61,49,0.3); }
  .btn-secondary { background: white; border: 2px solid var(--main-color); color: var(--main-color); }
  .btn-secondary:hover { background: var(--bg-color); }

  /* Tracer Specific */
  .tracer-layout {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 2rem;
  }

  .tracer-controls {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    background: rgba(0,0,0,0.02);
    padding: 2rem;
    border-radius: 1.5rem;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .control-group label {
    font-weight: 800;
    font-size: 0.9rem;
    color: var(--sub-color);
  }

  .svg-preview {
    width: 100%;
    min-height: 300px;
    height: auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: white;
    border-radius: 1rem;
    padding: 1.5rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    border: 1px solid #eee;
    overflow: hidden;
  }

  .canvas-info {
    margin-top: 1rem;
    font-size: 0.8rem;
    font-weight: 700;
    opacity: 0.5;
    text-align: center;
  }

  @media (max-width: 900px) {
    .tracer-layout {
      grid-template-columns: 1fr;
    }
    .tracer-controls {
      order: 2;
    }
  }
</style>
