---
import Layout from "@/layouts/Layout.astro";
import Container from "@/components/container.astro";
import Breadcrumbs from "@/components/ui/Breadcrumbs.astro";
---

<Layout 
  title="ç”»åƒã‚’ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ãƒ»SVGå¤‰æ› | ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼ - ãŠãŠã•ããƒ©ãƒœ" 
  description="ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸå†™çœŸã‚’ã‚¤ãƒ©ã‚¹ãƒˆé¢¨ã®ãƒ™ã‚¯ã‚¿ãƒ¼ç”»åƒï¼ˆSVGï¼‰ã«ç¬æ™‚ã«å¤‰æ›ã€‚è‰²æ•°ã‚„ãªã‚ã‚‰ã‹ã•ã‚’èª¿æ•´ã—ã¦ã€ãƒ­ã‚´åˆ¶ä½œã‚„ãƒ•ãƒ©ãƒƒãƒˆãƒ‡ã‚¶ã‚¤ãƒ³ã®ç´ æä½œã‚Šã«æ´»ç”¨ã§ãã¾ã™ã€‚"
>
  <Container>
    <Breadcrumbs items={[
      { label: "ãŠãŠã•ããƒ©ãƒœ", href: "/lab" },
      { label: "ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼" }
    ]} />

    <div class="tool-header-section">
      <div class="tool-icon-wrapper">
        <div class="tool-icon">ğŸ–‹ï¸</div>
      </div>
      <div class="tool-info">
        <h1 class="tool-title">ã„ã‚ã‚ã¤ã‚ãƒ¼ã‹ãƒ¼</h1>
        <p class="tool-description">
          å†™çœŸã‚„ã‚¤ãƒ©ã‚¹ãƒˆã‚’ãã‚Œã„ãªç·šã®ãƒ™ã‚¯ã‚¿ãƒ¼ç”»åƒï¼ˆSVGï¼‰ã«å¤‰æ›ã—ã¾ã™ã€‚<br/>
          è‰²æ•°ã‚’èª¿æ•´ã—ã¦ã€ãƒ­ã‚´åˆ¶ä½œã‚„ãƒ•ãƒ©ãƒƒãƒˆãƒ‡ã‚¶ã‚¤ãƒ³ã®ç´ æä½œã‚Šã«ï¼
        </p>
        <div class="tool-guide">
          <span>ğŸ’¡</span> VRChatã§ä½¿ã„ãŸã„ï¼Ÿ <a href="/lab/msdf-generator">ã§ã‹ãƒ¼ã‚‹ã‚ãƒ¼ã‹ãƒ¼</a> ãŒä¾¿åˆ©ã ã‚ˆï¼
        </div>
      </div>
    </div>

    <div class="tool-card">
      <div class="tool-content">
        <div class="tracer-layout">
          <div class="tracer-controls">
            <div class="control-group">
              <label>è‰²æ•°</label>
              <input type="number" id="tr-colors" min="1" max="64" value="1" />
            </div>
            
            <div class="control-group">
              <label>æ‰‹å‹•ãƒ‘ãƒ¬ãƒƒãƒˆ</label>
              <div class="toggle-row">
                <button id="manual-palette-toggle" class="toggle-btn">
                  <span class="toggle-label-off">OFF</span>
                  <span class="toggle-label-on">ON</span>
                  <span class="toggle-knob"></span>
                </button>
                <button id="auto-fill-palette" class="auto-fill-btn hidden" title="è‡ªå‹•ã§è‰²ã‚’æŠ½å‡º">ğŸ¨</button>
              </div>
            </div>

            <div id="palette-editor" class="control-group palette-editor hidden">
              <label>ã‚¯ãƒªãƒƒã‚¯ã§è‰²å¤‰æ›´</label>
              <div id="palette-colors" class="palette-colors"></div>
            </div>

            <div class="control-group">
              <label>ãªã‚ã‚‰ã‹ã•</label>
              <select id="tr-detail">
                <option value="1">ä½ï¼ˆã‚«ã‚¯ã‚«ã‚¯ï¼‰</option>
                <option value="2" selected>ä¸­ï¼ˆæ¨™æº–ï¼‰</option>
                <option value="3">é«˜ï¼ˆãªã‚ã‚‰ã‹ï¼‰</option>
              </select>
            </div>
            <div class="control-group">
              <label>èƒŒæ™¯é€é</label>
              <div class="option-buttons">
                <button class="option-btn" data-transparency="none">ãªã—</button>
                <button class="option-btn active" data-transparency="topleft">å·¦ä¸Š</button>
                <button class="option-btn" data-transparency="most">æœ€å¤š</button>
              </div>
            </div>
            <div class="control-group">
              <label>ãƒˆãƒªãƒŸãƒ³ã‚°</label>
              <div class="option-buttons">
                <button class="option-btn" data-trim="none">ãªã—</button>
                <button class="option-btn" data-trim="min">æœ€å°</button>
                <button class="option-btn active" data-trim="square">æ­£æ–¹å½¢</button>
              </div>
            </div>
            <div class="actions">
              <button id="tr-download" class="btn btn-primary">
                <span>ğŸ’¾</span> ä¿å­˜
              </button>
            </div>
          </div>

          <div class="tracer-preview">
            <div class="drop-zone" id="tr-drop-zone">
              <input type="file" id="tr-file-input" accept="image/*" class="file-input" />
              <div class="drop-zone-text">
                <span class="upload-icon">ğŸ–‹ï¸</span>
                <p>ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–</p>
              </div>
            </div>
            <div id="tr-preview-container" class="preview-container hidden">
              <div id="tr-svg-container" class="svg-preview"></div>
              <canvas id="source-canvas" class="source-canvas hidden"></canvas>
              <div id="picking-hint" class="picking-hint hidden">ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è‰²ã‚’é¸æŠ</div>
              <div class="canvas-info">åˆ¥ã®ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã§å¤‰æ›´</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </Container>
</Layout>

<script is:inline src="https://unpkg.com/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>
<script is:inline src="https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.js"></script>

<script>
  // ============================================
  // è¦ç´ å–å¾—
  // ============================================
  const trDropZone = document.getElementById('tr-drop-zone');
  const trFileInput = document.getElementById('tr-file-input') as HTMLInputElement;
  const trPreviewContainer = document.getElementById('tr-preview-container');
  const trSvgContainer = document.getElementById('tr-svg-container');
  const trDownloadBtn = document.getElementById('tr-download');
  const trColorsInput = document.getElementById('tr-colors') as HTMLInputElement;
  const trDetailSelect = document.getElementById('tr-detail') as HTMLSelectElement;
  const manualPaletteToggle = document.getElementById('manual-palette-toggle');
  const paletteEditor = document.getElementById('palette-editor');
  const paletteColors = document.getElementById('palette-colors');
  const sourceCanvas = document.getElementById('source-canvas') as HTMLCanvasElement;
  const pickingHint = document.getElementById('picking-hint');
  const autoFillBtn = document.getElementById('auto-fill-palette');

  // ============================================
  // çŠ¶æ…‹ç®¡ç†
  // ============================================
  let trSourceImage: string | null = null;
  let sourceImageElement: HTMLImageElement | null = null;
  let currentSvgStr: string | null = null;
  let transparencyMode: 'none' | 'topleft' | 'most' = 'topleft';
  let trimMode: 'none' | 'min' | 'square' = 'square';

  // æ‰‹å‹•ãƒ‘ãƒ¬ãƒƒãƒˆé–¢é€£
  let isManualPalette = false;
  let manualPalette: { r: number, g: number, b: number, a: number }[] = [];
  let currentPickingIndex: number | null = null;

  // ============================================
  // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
  // ============================================
  function setupOptionButtons(selector: string, callback: (value: string) => void) {
    document.querySelectorAll(selector).forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        
        if (target.classList.contains('disabled')) return;
        
        const parent = target.parentElement;
        parent?.querySelectorAll('.option-btn').forEach(b => b.classList.remove('active'));
        target.classList.add('active');
        callback(target.dataset.transparency || target.dataset.trim || '');
      });
    });
  }

  setupOptionButtons('[data-transparency]', (value) => {
    transparencyMode = value as typeof transparencyMode;
    if (isManualPalette) {
      renderPaletteUI();
    }
    render();
  });

  setupOptionButtons('[data-trim]', (value) => {
    trimMode = value as typeof trimMode;
    render();
  });

  // ============================================
  // æ‰‹å‹•ãƒ‘ãƒ¬ãƒƒãƒˆã®ãƒˆã‚°ãƒ«
  // ============================================
  manualPaletteToggle?.addEventListener('click', () => {
    isManualPalette = !isManualPalette;
    manualPaletteToggle.classList.toggle('active', isManualPalette);
    paletteEditor?.classList.toggle('hidden', !isManualPalette);
    autoFillBtn?.classList.toggle('hidden', !isManualPalette);
    
    if (isManualPalette) {
      if (transparencyMode === 'most') {
        transparencyMode = 'none';
        document.querySelectorAll('[data-transparency]').forEach(btn => {
          const button = btn as HTMLButtonElement;
          button.classList.toggle('active', button.dataset.transparency === 'none');
        });
      }
      updateTransparencyButtons();
      initManualPalette();
    } else {
      updateTransparencyButtons();
      exitPickingMode();
    }
    render();
  });

  // ============================================
  // é€éãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹åˆ‡ã‚Šæ›¿ãˆ
  // ============================================
  function updateTransparencyButtons() {
    document.querySelectorAll('[data-transparency]').forEach(btn => {
      const button = btn as HTMLButtonElement;
      const mode = button.dataset.transparency;
      
      if (isManualPalette) {
        if (mode === 'most') {
          button.classList.add('disabled');
        } else if (mode === 'topleft') {
          button.textContent = 'æœ€åˆ';
        }
      } else {
        button.classList.remove('disabled');
        if (mode === 'topleft') {
          button.textContent = 'å·¦ä¸Š';
        }
      }
    });
  }

  // ============================================
  // æ‰‹å‹•ãƒ‘ãƒ¬ãƒƒãƒˆã®åˆæœŸåŒ–
  // ============================================
  function initManualPalette() {
    const numColors = parseInt(trColorsInput.value);
    
    manualPalette = [];
    for (let i = 0; i < numColors; i++) {
      manualPalette.push({ r: 128, g: 128, b: 128, a: 255 });
    }
    
    renderPaletteUI();
  }

  // ============================================
  // è‰²ã®å¤šæ§˜æ€§é‡è¦–ã§ãƒ‘ãƒ¬ãƒƒãƒˆæŠ½å‡º
  // ============================================
  function extractDiversePalette(numColors: number): { r: number, g: number, b: number, a: number }[] {
    if (!sourceImageElement) return [];

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return [];

    canvas.width = sourceImageElement.width;
    canvas.height = sourceImageElement.height;
    ctx.drawImage(sourceImageElement, 0, 0);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    
    // è‰²ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦å¹³å‡è‰²ã‚’è¨ˆç®—
    const colorGroups = new Map<string, { count: number, sumR: number, sumG: number, sumB: number }>();
    const step = Math.max(1, Math.floor(pixels.length / 4 / 10000));
    
    for (let i = 0; i < pixels.length; i += 4 * step) {
      const r = pixels[i];
      const g = pixels[i + 1];
      const b = pixels[i + 2];
      // 16åˆ»ã¿ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
      const key = `${Math.floor(r/16)*16},${Math.floor(g/16)*16},${Math.floor(b/16)*16}`;
      
      if (!colorGroups.has(key)) {
        colorGroups.set(key, { count: 1, sumR: r, sumG: g, sumB: b });
      } else {
        const group = colorGroups.get(key)!;
        group.count++;
        group.sumR += r;
        group.sumG += g;
        group.sumB += b;
      }
    }
    
    // ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰å¹³å‡è‰²ã‚’è¨ˆç®—
    const allColors: { r: number, g: number, b: number, count: number }[] = [];
    colorGroups.forEach((group) => {
      allColors.push({
        r: Math.round(group.sumR / group.count),
        g: Math.round(group.sumG / group.count),
        b: Math.round(group.sumB / group.count),
        count: group.count
      });
    });
    
    if (allColors.length === 0) return [];
    
    // æœ€ã‚‚é ã„è‰²ã‚’é †ç•ªã«é¸ã¶
    const selected: { r: number, g: number, b: number }[] = [];
    
    // æœ€åˆã¯æœ€ã‚‚å‡ºç¾å›æ•°ãŒå¤šã„è‰²
    allColors.sort((a, b) => b.count - a.count);
    selected.push({ r: allColors[0].r, g: allColors[0].g, b: allColors[0].b });
    
    while (selected.length < numColors && allColors.length > selected.length) {
      let maxMinDist = -1;
      let bestColor: { r: number, g: number, b: number } | null = null;
      
      for (const color of allColors) {
        // ã™ã§ã«é¸ã°ã‚Œã¦ãŸã‚‰ã‚¹ã‚­ãƒƒãƒ—
        const alreadySelected = selected.some(s => 
          Math.abs(s.r - color.r) < 10 && Math.abs(s.g - color.g) < 10 && Math.abs(s.b - color.b) < 10
        );
        if (alreadySelected) continue;
        
        // é¸ã°ã‚ŒãŸè‰²ãŸã¡ã¨ã®æœ€å°è·é›¢ã‚’è¨ˆç®—
        const minDist = Math.min(...selected.map(s => 
          Math.sqrt((s.r - color.r) ** 2 + (s.g - color.g) ** 2 + (s.b - color.b) ** 2)
        ));
        
        // æœ€å°è·é›¢ãŒæœ€å¤§ã®ã‚‚ã®ã‚’é¸ã¶
        if (minDist > maxMinDist) {
          maxMinDist = minDist;
          bestColor = { r: color.r, g: color.g, b: color.b };
        }
      }
      
      if (bestColor) {
        selected.push(bestColor);
      } else {
        break;
      }
    }
    
    return selected.map(c => ({ r: c.r, g: c.g, b: c.b, a: 255 }));
  }

  // è‡ªå‹•æŠ½å‡ºãƒœã‚¿ãƒ³
  autoFillBtn?.addEventListener('click', () => {
    if (!sourceImageElement) return;
    
    const numColors = parseInt(trColorsInput.value);
    const extracted = extractDiversePalette(numColors);
    if (extracted.length > 0) {
      manualPalette = extracted;
      renderPaletteUI();
      render();
    }
  });

  // ============================================
  // ãƒ‘ãƒ¬ãƒƒãƒˆUIã®æç”»
  // ============================================
  function renderPaletteUI() {
    if (!paletteColors) return;
    
    const numColors = parseInt(trColorsInput.value);
    
    while (manualPalette.length < numColors) {
      manualPalette.push({ r: 128, g: 128, b: 128, a: 255 });
    }
    manualPalette = manualPalette.slice(0, numColors);
    
    paletteColors.innerHTML = '';
    
    manualPalette.forEach((color, index) => {
      const colorBtn = document.createElement('button');
      colorBtn.className = 'palette-color-btn';
      colorBtn.textContent = 'â– ';
      colorBtn.style.color = `rgb(${color.r}, ${color.g}, ${color.b})`;
      
      if (index === 0 && transparencyMode === 'topleft') {
        colorBtn.classList.add('transparent-color');
        colorBtn.title = `è‰²${index + 1}: é€éè‰²`;
      } else {
        colorBtn.title = `è‰²${index + 1}`;
      }
      
      if (currentPickingIndex === index) {
        colorBtn.classList.add('picking');
      }
      
      colorBtn.addEventListener('click', () => {
        startColorPicking(index);
      });
      
      paletteColors.appendChild(colorBtn);
    });
  }

  // ============================================
  // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚­ãƒ³ã‚°
  // ============================================
  function startColorPicking(index: number) {
    currentPickingIndex = index;
    renderPaletteUI();
    
    if (trSvgContainer) trSvgContainer.classList.add('hidden');
    if (sourceCanvas) {
      sourceCanvas.classList.remove('hidden');
      drawSourceCanvas();
    }
    if (pickingHint) pickingHint.classList.remove('hidden');
    
    sourceCanvas?.classList.add('picking-mode');
  }

  function drawSourceCanvas() {
    if (!sourceImageElement || !sourceCanvas) return;
    
    const ctx = sourceCanvas.getContext('2d');
    if (!ctx) return;
    
    const maxSize = 400;
    const scale = Math.min(maxSize / sourceImageElement.width, maxSize / sourceImageElement.height, 1);
    
    sourceCanvas.width = sourceImageElement.width * scale;
    sourceCanvas.height = sourceImageElement.height * scale;
    
    ctx.drawImage(sourceImageElement, 0, 0, sourceCanvas.width, sourceCanvas.height);
  }

  function exitPickingMode() {
    currentPickingIndex = null;
    renderPaletteUI();
    
    if (trSvgContainer) trSvgContainer.classList.remove('hidden');
    if (sourceCanvas) sourceCanvas.classList.add('hidden');
    if (pickingHint) pickingHint.classList.add('hidden');
    sourceCanvas?.classList.remove('picking-mode');
  }

  sourceCanvas?.addEventListener('click', (e) => {
    if (currentPickingIndex === null) return;
    
    const rect = sourceCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const ctx = sourceCanvas.getContext('2d');
    if (!ctx) return;
    
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    
    manualPalette[currentPickingIndex] = {
      r: pixel[0],
      g: pixel[1],
      b: pixel[2],
      a: 255
    };
    
    exitPickingMode();
    render();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && currentPickingIndex !== null) {
      exitPickingMode();
    }
  });

  // ============================================
  // ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
  // ============================================
  function handleFile(file: File) {
    if (!file.type.startsWith('image/')) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        sourceImageElement = img;
        trSourceImage = e.target?.result as string;
        trDropZone?.classList.add('hidden');
        trPreviewContainer?.classList.remove('hidden');
        
        if (isManualPalette) {
          initManualPalette();
        }
        
        render();
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }

  // ============================================
  // ãƒ‘ãƒ¬ãƒƒãƒˆæŠ½å‡ºï¼ˆè‡ªå‹•ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
  // ============================================
  function extractPalette(numColors: number): { r: number, g: number, b: number, a: number }[] {
    if (!sourceImageElement) return [];

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return [];

    canvas.width = sourceImageElement.width;
    canvas.height = sourceImageElement.height;
    ctx.drawImage(sourceImageElement, 0, 0);

    // @ts-ignore
    const q = new RgbQuant({
      colors: numColors,
      method: 2,
      minHueCols: 256,
    });

    q.sample(canvas);
    const palette = q.palette(true);

    return palette.map((c: number[]) => ({
      r: c[0],
      g: c[1],
      b: c[2],
      a: 255
    }));
  }

  // ============================================
  // è‰²é–¢é€£ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  // ============================================
  function getTopLeftPixelColor(): { r: number, g: number, b: number } | null {
    if (!sourceImageElement) return null;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;

    canvas.width = sourceImageElement.width;
    canvas.height = sourceImageElement.height;
    ctx.drawImage(sourceImageElement, 0, 0);
    const pixel = ctx.getImageData(0, 0, 1, 1).data;

    return { r: pixel[0], g: pixel[1], b: pixel[2] };
  }

  function parseFillColor(fill: string): { r: number, g: number, b: number } | null {
    const rgbMatch = fill.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (rgbMatch) {
      return {
        r: parseInt(rgbMatch[1]),
        g: parseInt(rgbMatch[2]),
        b: parseInt(rgbMatch[3])
      };
    }

    const hexMatch = fill.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if (hexMatch) {
      return {
        r: parseInt(hexMatch[1], 16),
        g: parseInt(hexMatch[2], 16),
        b: parseInt(hexMatch[3], 16)
      };
    }

    return null;
  }

  function colorDistance(c1: { r: number, g: number, b: number }, c2: { r: number, g: number, b: number }): number {
    return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
  }

  // ============================================
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  // ============================================
  function render() {
    if (!trSourceImage || !trSvgContainer) return;

    const numColors = parseInt(trColorsInput.value);
    const detail = parseInt(trDetailSelect.value);
    const needsTransparency = transparencyMode !== 'none';

    let palette: { r: number, g: number, b: number, a: number }[];
    
    if (isManualPalette) {
      palette = [...manualPalette];
    } else {
      const internalColors = needsTransparency ? numColors + 1 : numColors;
      palette = extractPalette(internalColors);
    }

    // @ts-ignore
    ImageTracer.imageToSVG(
      trSourceImage,
      (svgstr: string) => {
        if (needsTransparency) {
          svgstr = applyTransparency(svgstr);
        }
        if (trimMode !== 'none') {
          svgstr = applyTrim(svgstr);
        }
        currentSvgStr = svgstr;
        if (trSvgContainer) trSvgContainer.innerHTML = svgstr;
      },
      {
        pal: palette,
        numberofcolors: palette.length,
        colorsampling: 0,
        colorquantcycles: 1,
        ltres: detail === 3 ? 0.05 : detail === 2 ? 2 : 20,
        qtres: detail === 3 ? 0.05 : detail === 2 ? 2 : 20,
        pathomit: detail === 3 ? 8 : detail === 2 ? 64 : 512,
        strokewidth: 0,
        viewbox: true,
        blurradius: detail === 1 ? 3 : 0,
        blurdelta: 20
      }
    );
  }

  // ============================================
  // é€éå‡¦ç†
  // ============================================
  function applyTransparency(svgstr: string): string {
    if (transparencyMode === 'none') return svgstr;
    
    const temp = document.createElement('div');
    temp.style.position = 'absolute';
    temp.style.visibility = 'hidden';
    temp.innerHTML = svgstr;
    document.body.appendChild(temp);

    const svg = temp.querySelector('svg');
    if (!svg) {
      document.body.removeChild(temp);
      return svgstr;
    }

    const paths = svg.querySelectorAll('path');
    if (paths.length === 0) {
      document.body.removeChild(temp);
      return svgstr;
    }

    let targetColor: string | null = null;
    let transparentColorRef: { r: number, g: number, b: number } | null = null;
    
    if (isManualPalette) {
      if (manualPalette.length > 0) {
        transparentColorRef = manualPalette[0];
      }
    } else if (transparencyMode === 'topleft') {
      transparentColorRef = getTopLeftPixelColor();
    } else if (transparencyMode === 'most') {
      const colorArea = new Map<string, number>();

      paths.forEach(path => {
        const fill = path.getAttribute('fill') || '';
        try {
          const bbox = (path as SVGPathElement).getBBox();
          const area = bbox.width * bbox.height;
          colorArea.set(fill, (colorArea.get(fill) || 0) + area);
        } catch (e) {}
      });

      let maxArea = 0;
      colorArea.forEach((area, color) => {
        if (area > maxArea) {
          maxArea = area;
          targetColor = color;
        }
      });
    }

    if (transparentColorRef && !targetColor) {
      const svgColors = new Set<string>();
      paths.forEach(path => {
        const fill = path.getAttribute('fill');
        if (fill) svgColors.add(fill);
      });

      let minDist = Infinity;
      svgColors.forEach(fill => {
        const parsed = parseFillColor(fill);
        if (parsed) {
          const dist = colorDistance(transparentColorRef!, parsed);
          if (dist < minDist) {
            minDist = dist;
            targetColor = fill;
          }
        }
      });
    }

    if (targetColor) {
      paths.forEach(path => {
        if (path.getAttribute('fill') === targetColor) {
          path.remove();
        }
      });
    }

    const result = new XMLSerializer().serializeToString(svg);
    document.body.removeChild(temp);
    return result;
  }

  // ============================================
  // ãƒˆãƒªãƒŸãƒ³ã‚°å‡¦ç†
  // ============================================
  function applyTrim(svgstr: string): string {
    const temp = document.createElement('div');
    temp.style.position = 'absolute';
    temp.style.visibility = 'hidden';
    temp.innerHTML = svgstr;
    document.body.appendChild(temp);

    const svg = temp.querySelector('svg');
    if (!svg) {
      document.body.removeChild(temp);
      return svgstr;
    }

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    svg.querySelectorAll('path').forEach(path => {
      try {
        const bbox = (path as SVGPathElement).getBBox();
        minX = Math.min(minX, bbox.x);
        minY = Math.min(minY, bbox.y);
        maxX = Math.max(maxX, bbox.x + bbox.width);
        maxY = Math.max(maxY, bbox.y + bbox.height);
      } catch (e) {}
    });

    document.body.removeChild(temp);

    if (minX === Infinity) return svgstr;

    const parser = new DOMParser();
    const doc = parser.parseFromString(svgstr, 'image/svg+xml');
    const svgEl = doc.querySelector('svg');
    if (!svgEl) return svgstr;

    let width = maxX - minX;
    let height = maxY - minY;
    let viewBoxX = minX;
    let viewBoxY = minY;

    if (trimMode === 'square') {
      const size = Math.max(width, height);
      viewBoxX = minX - (size - width) / 2;
      viewBoxY = minY - (size - height) / 2;
      width = size;
      height = size;
    }

    svgEl.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${width} ${height}`);
    svgEl.removeAttribute('width');
    svgEl.removeAttribute('height');

    return new XMLSerializer().serializeToString(svgEl);
  }

  // ============================================
  // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®š
  // ============================================
  function setupDropZone(element: HTMLElement | null) {
    if (!element) return;

    element.addEventListener('dragover', (e) => {
      e.preventDefault();
      element.classList.add('drag-over');
    });

    ['dragleave', 'dragend'].forEach(t =>
      element.addEventListener(t, () => element.classList.remove('drag-over'))
    );

    element.addEventListener('drop', (e) => {
      e.preventDefault();
      element.classList.remove('drag-over');
      if (e.dataTransfer?.files.length) handleFile(e.dataTransfer.files[0]);
    });
  }

  // ============================================
  // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
  // ============================================
  trColorsInput?.addEventListener('change', () => {
    if (isManualPalette) {
      renderPaletteUI();
    }
    render();
  });
  
  trDetailSelect?.addEventListener('change', render);

  trDropZone?.addEventListener('click', () => trFileInput?.click());
  setupDropZone(trDropZone);

  setupDropZone(trSvgContainer);
  trSvgContainer?.addEventListener('click', () => {
    if (currentPickingIndex === null) {
      trFileInput?.click();
    }
  });

  trFileInput?.addEventListener('change', () => {
    if (trFileInput.files?.length) handleFile(trFileInput.files[0]);
  });

  trDownloadBtn?.addEventListener('click', () => {
    if (!currentSvgStr) return;
    const blob = new Blob([currentSvgStr], { type: 'image/svg+xml' });
    const link = document.createElement('a');
    link.download = 'vectorized.svg';
    link.href = URL.createObjectURL(blob);
    link.click();
  });
</script>

<style>
  .tool-header-section {
    display: flex;
    align-items: center;
    gap: 2rem;
    margin-bottom: 3rem;
  }

  .tool-icon-wrapper {
    background: white;
    width: 6rem;
    height: 6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.1);
  }

  .tool-icon {
    font-size: 3rem;
  }

  .tool-title {
    font-size: 2rem;
    font-weight: 900;
    color: var(--main-color);
    margin-bottom: 0.5rem;
  }

  .tool-description {
    font-size: 1.1rem;
    color: var(--sub-color);
    opacity: 0.8;
    line-height: 1.6;
  }

  .tool-guide {
    margin-top: 0.75rem;
    font-size: 0.9rem;
    font-weight: 700;
    color: var(--sub-color);
    background: rgba(0, 0, 0, 0.03);
    padding: 0.5rem 1rem;
    border-radius: 0.75rem;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
  }

  .tool-guide a {
    color: var(--main-color);
    text-decoration: underline;
    text-underline-offset: 4px;
    transition: opacity 0.2s;
  }

  .tool-guide a:hover {
    opacity: 0.7;
  }

  .tool-card {
    background: white;
    border: 2px solid var(--main-color);
    border-radius: 2rem;
    padding: 3rem;
    margin-bottom: 3rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.05);
  }

  .drop-zone {
    border: 3px dashed var(--main-color);
    border-radius: 2rem;
    padding: 4rem 2rem;
    text-align: center;
    cursor: pointer;
    background: rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease;
  }

  .drop-zone:hover, .drop-zone.drag-over {
    background: var(--bg-color);
    border-color: var(--accent-color);
    transform: scale(1.02);
  }

  .upload-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: 1rem;
  }

  .file-input { display: none; }
  .hidden { display: none !important; }

  .tracer-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 2rem;
  }

  .tracer-controls {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    background: rgba(0,0,0,0.02);
    padding: 1.5rem;
    border-radius: 1.5rem;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .control-group label {
    font-weight: 800;
    font-size: 0.9rem;
    color: var(--sub-color);
  }

  input[type="number"], select {
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 1px solid #ddd;
    font-size: 1rem;
  }

  .option-buttons {
    display: flex;
    gap: 0.5rem;
  }

  .option-btn {
    flex: 1;
    padding: 0.5rem;
    border-radius: 0.5rem;
    border: 2px solid #ddd;
    background: white;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 700;
    transition: all 0.2s ease;
    color: var(--sub-color);
  }

  .option-btn:hover:not(.disabled) {
    border-color: var(--main-color);
    background: var(--bg-color);
  }

  .option-btn.active {
    border-color: var(--main-color);
    background: var(--main-color);
    color: white;
  }

  .option-btn.disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  /* ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ */
  .toggle-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .toggle-btn {
    position: relative;
    width: 80px;
    height: 36px;
    border-radius: 18px;
    border: 2px solid #ddd;
    background: #eee;
    cursor: pointer;
    transition: all 0.3s ease;
    overflow: hidden;
  }

  .toggle-btn .toggle-label-off,
  .toggle-btn .toggle-label-on {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.75rem;
    font-weight: 800;
    transition: opacity 0.2s;
  }

  .toggle-btn .toggle-label-off {
    right: 10px;
    color: #888;
  }

  .toggle-btn .toggle-label-on {
    left: 10px;
    color: white;
    opacity: 0;
  }

  .toggle-btn .toggle-knob {
    position: absolute;
    top: 3px;
    left: 3px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
  }

  .toggle-btn.active {
    background: var(--main-color);
    border-color: var(--main-color);
  }

  .toggle-btn.active .toggle-knob {
    left: calc(100% - 29px);
  }

  .toggle-btn.active .toggle-label-off {
    opacity: 0;
  }

  .toggle-btn.active .toggle-label-on {
    opacity: 1;
  }

  /* è‡ªå‹•æŠ½å‡ºãƒœã‚¿ãƒ³ */
  .auto-fill-btn {
    background: white;
    border: 2px solid #ddd;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    cursor: pointer;
    font-size: 1.1rem;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .auto-fill-btn:hover {
    border-color: var(--main-color);
    transform: scale(1.1);
  }

  /* ãƒ‘ãƒ¬ãƒƒãƒˆã‚¨ãƒ‡ã‚£ã‚¿ */
  .palette-editor {
    background: rgba(0,0,0,0.03);
    padding: 1rem;
    border-radius: 1rem;
    margin-top: -0.5rem;
  }

  .palette-colors {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }

  .palette-color-btn {
    background: white;
    border: 2px solid #ddd;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0.25rem;
    font-size: 1.5rem;
    line-height: 1;
  }

  .palette-color-btn:hover {
    border-color: var(--main-color);
    transform: scale(1.1);
  }

  .palette-color-btn.picking {
    border-color: var(--main-color);
    animation: pulse 1s infinite;
  }

  .palette-color-btn.transparent-color {
    position: relative;
    opacity: 0.5;
  }

  .palette-color-btn.transparent-color::after {
    content: 'ï¼';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    color: #666;
    pointer-events: none;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  /* ã‚½ãƒ¼ã‚¹ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚¯ç”¨ï¼‰ */
  .source-canvas {
    border-radius: 1rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    max-width: 100%;
  }

  .source-canvas.picking-mode {
    cursor: crosshair;
  }

  .picking-hint {
    margin-top: 1rem;
    padding: 0.75rem 1.5rem;
    background: var(--main-color);
    color: white;
    border-radius: 2rem;
    font-weight: 700;
    font-size: 0.9rem;
    text-align: center;
    animation: bounce 0.5s ease;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
  }

  .actions {
    margin-top: 1rem;
  }

  .btn {
    width: 100%;
    padding: 0.75rem 1.5rem;
    border-radius: 1rem;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    font-size: 1rem;
  }

  .btn-primary { 
    background: var(--main-color); 
    color: white; 
  }
  
  .btn-primary:hover { 
    transform: translateY(-3px); 
    box-shadow: 0 10px 20px rgba(207,61,49,0.3); 
  }

  .svg-preview {
    width: 100%;
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: white;
    border-radius: 1rem;
    padding: 1.5rem;
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    border: 1px solid #eee;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .svg-preview:hover {
    border-color: var(--main-color);
  }

  .svg-preview.drag-over {
    border: 3px dashed var(--accent-color);
    background: var(--bg-color);
  }

  .canvas-info {
    margin-top: 1rem;
    font-size: 0.8rem;
    font-weight: 700;
    opacity: 0.5;
    text-align: center;
  }

  @media (max-width: 900px) {
    .tracer-layout {
      grid-template-columns: 1fr;
    }
    .tracer-controls {
      order: 2;
    }
  }
</style>